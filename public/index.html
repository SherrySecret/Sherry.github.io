<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/18/hello-world/" class="article-date">
  <time class="dt-published" datetime="2024-06-18T05:37:45.388Z" itemprop="datePublished">2024-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/18/hello-world/">NMSL</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a><br>try</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/18/hello-world/" data-id="clxjz1pnx0001h8v46eilbc42" data-title="NMSL" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-letcode" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/16/letcode/" class="article-date">
  <time class="dt-published" datetime="2024-06-16T04:32:45.000Z" itemprop="datePublished">2024-06-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/16/letcode/">letcode</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        Here's something encrypted, password is required to continue reading.
        
          <p class="article-more-link">
            <a href="/2024/06/16/letcode/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/16/letcode/" data-id="clxjz1po90002h8v4c5vmcz26" data-title="letcode" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-test" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/16/test/" class="article-date">
  <time class="dt-published" datetime="2024-06-16T04:32:45.000Z" itemprop="datePublished">2024-06-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/16/test/">letcode</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="LeetCode题库"><a href="#LeetCode题库" class="headerlink" title="LeetCode题库"></a>LeetCode题库</h1><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><h3 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p>示例 1：</p>
<p><strong>输入：</strong>nums &#x3D; [2,7,11,15], target &#x3D; 9<br><strong>输出：</strong>[0,1]<br><strong>解释：</strong>因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<br>示例 2：</p>
<p><strong>输入：</strong>nums &#x3D; [3,2,4], target &#x3D; 6<br><strong>输出：</strong>[1,2]<br>示例 3：</p>
<p><strong>输入：</strong>nums &#x3D; [3,3], target &#x3D; 6<br><strong>输出：</strong>[0,1]</p>
<p><strong>提示：</strong></p>
<p>2 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>-109 &lt;&#x3D; target &lt;&#x3D; 109<br>只会存在一个有效答案</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><h4 id="1-穷举法"><a href="#1-穷举法" class="headerlink" title="1. 穷举法"></a>1. 穷举法</h4><p><strong>思路</strong>：通过for循环确定数组中是否有target-x，两层循环令i和j逐步后移，找到目标返回数组下标，反之返回数组0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]==target-nums[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>时间复杂度：</strong> <em>O（n²）</em> 最坏的情况每个元素都要与其它元素比对。</p>
<p><strong>空间复杂度：</strong> <em>O（1 ）</em></p>
<h4 id="2-哈希表"><a href="#2-哈希表" class="headerlink" title="2. 哈希表"></a>2. 哈希表</h4><p><strong>思路：</strong> 在每一层循环中，都在哈希表中寻找是否有对应元素的目标值，若没有，则加入表中，反之，输出结果即可，以空间减少时间耗费。以此来降低时间复杂度，解决时间复杂度较高的bug。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        Map&lt;Integer, Integer&gt; hashtbl = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hashtbl.containsKey(target-nums[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;hashtbl.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtbl.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度：</strong> <em>O（n）</em></p>
<p><strong>空间复杂度：</strong> <em>O（n）</em></p>
<h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h2><h3 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h3><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例 1：</p>
<p>输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 &#x3D; 807.<br>示例 2：</p>
<p>输入：l1 &#x3D; [0], l2 &#x3D; [0]<br>输出：[0]<br>示例 3：</p>
<p>输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]</p>
<p>提示：</p>
<p>每个链表中的节点数在范围 [1, 100] 内<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 9<br>题目数据保证列表表示的数字不含前导零</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><h4 id="模拟法"><a href="#模拟法" class="headerlink" title="模拟法"></a>模拟法</h4><p><strong>思路</strong>： 由于输入的两个链表都是逆序存储数字的位数的，因此两个链表中同一位置的数字可以直接相加。</p>
<p>我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。具体而言，如果当前两个链表处相应位置的数字为 n1,n2n1,n2，进位值为 carry，则它们的和为n1+n2+carry</p>
<p>如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 0。</p>
<p>此外，如果链表遍历结束后，有carry&gt;0，还需要在答案链表的后面附加一个节点，节点的值为 carry。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        ListNode head=<span class="literal">null</span>,tail=<span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> carry=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">null</span>||l2!=<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> l1 != <span class="literal">null</span> ? l1.val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> l2 != <span class="literal">null</span> ? l2.val : <span class="number">0</span>;</span><br><span class="line">            sum=n1+n2+carry;</span><br><span class="line">            <span class="keyword">if</span>(head==<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                head=tail=<span class="keyword">new</span> <span class="title class_">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tail.next=<span class="keyword">new</span> <span class="title class_">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">                tail=tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                l1=l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">if</span>(l2!=<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                l2=l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            carry=sum/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tail.next=<span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度：</strong><em>O（max(m,n)）</em></p>
<p><strong>空间复杂度：</strong><em>O（max(m,n)）</em></p>
<p>m,n为两个链表的长度。</p>
<h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h2><h3 id="题干-2"><a href="#题干-2" class="headerlink" title="题干"></a>题干</h3><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p><strong>示例 1:</strong></p>
<p>输入: s &#x3D; “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p><strong>示例 2:</strong></p>
<p>输入: s &#x3D; “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
<p><strong>示例 3:</strong></p>
<p>输入: s &#x3D; “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<p><em><strong>提示：</strong></em></p>
<p>0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104<br>s 由英文字母、数字、符号和空格组成</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p><strong>思路：</strong>由于要找字符串中的最长子串的长度，因此需要每次加入一个字符且统计此时的长度，并引入max不断更新最大值。联想到第一题所用的哈希表，在此处建立一个有Character和Integer组成的哈希表，记录每次加入的字符和其序号索引，每次加入一个字符便进行一次判断，哈希表中是否有新字符的重复项，若有，则将左指针直接指向右指针的下一位字符，继续进行寻找，每轮循环更新max，start，end值，最终return max即得以求解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character,Integer&gt;map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">        <span class="type">int</span> n=s.length();</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>,end=<span class="number">0</span>,max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(end=<span class="number">0</span>;end&lt;n;++end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> ch=s.charAt(end);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(ch))</span><br><span class="line">            &#123;</span><br><span class="line">                start=Math.max(map.get(ch)+<span class="number">1</span>,start);</span><br><span class="line">            &#125;</span><br><span class="line">            max=Math.max(max,end-start+<span class="number">1</span>);</span><br><span class="line">            map.put(ch,end);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**时间复杂度： ** <em>O（N）</em>字符串长度为N，指针遍历整个字符串。</p>
<p><strong>空间复杂度：</strong> <em>O（∣Σ∣）</em>其中 \SigmaΣ 表示字符集（即字符串中可以出现的字符），∣Σ∣ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0,128) 内的字符， ∣Σ∣&#x3D;128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 ∣Σ∣ 个，因此空间复杂度为 O(∣Σ∣)。</p>
<h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h2><h3 id="题干-3"><a href="#题干-3" class="headerlink" title="题干"></a>题干</h3><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p>
<p>算法的时间复杂度应该为 O(log (m+n)) 。</p>
<p>示例 1：</p>
<p>输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]<br>输出：2.00000<br>解释：合并数组 &#x3D; [1,2,3] ，中位数 2<br>示例 2：</p>
<p>输入：nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]<br>输出：2.50000<br>解释：合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5</p>
<p>提示：</p>
<p>nums1.length &#x3D;&#x3D; m<br>nums2.length &#x3D;&#x3D; n<br>0 &lt;&#x3D; m &lt;&#x3D; 1000<br>0 &lt;&#x3D; n &lt;&#x3D; 1000<br>1 &lt;&#x3D; m + n &lt;&#x3D; 2000<br>-10^6&lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 10^6</p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><strong>思路：</strong>先通过循环将两个数组连接，然后通过快速排序将合并的数组排列好，进而输出中位数。</p>
<p><strong>注意：</strong>由于中位数存在两数之和的一半的情况，因此数组应定义为double等类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> m=nums1.length;</span><br><span class="line">        <span class="type">int</span> n= nums2.length;</span><br><span class="line">        <span class="type">double</span>[] nums3=<span class="keyword">new</span> <span class="title class_">double</span> [m+n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nums3[i]=nums1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m;i&lt;m+n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nums3[i]=nums2[i-m];</span><br><span class="line">        &#125;</span><br><span class="line">        Quick_Sort(nums3,<span class="number">0</span>,m+n-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>((m+n)%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ((nums3[(m+n)/<span class="number">2</span>]+nums3[(m+n)/<span class="number">2</span>-<span class="number">1</span>])/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums3[(m+n-<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">Quick_Sort</span><span class="params">(<span class="type">double</span> []arr,<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin &gt; end)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">double</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[begin];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> end;</span><br><span class="line">    <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[j] &gt;= tmp &amp;&amp; j &gt; i)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">while</span>(arr[i] &lt;= tmp &amp;&amp; j &gt; i)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(j &gt; i)&#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[begin] = arr[i];</span><br><span class="line">    arr[i] = tmp;</span><br><span class="line">    Quick_Sort(arr, begin, i-<span class="number">1</span>);</span><br><span class="line">    Quick_Sort(arr, i+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>快速排序的算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">Quick_Sort</span><span class="params">(<span class="type">int</span> []arr,<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin &gt; end)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[begin];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> end;</span><br><span class="line">    <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[j] &gt;= tmp &amp;&amp; j &gt; i)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">while</span>(arr[i] &lt;= tmp &amp;&amp; j &gt; i)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(j &gt; i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[begin] = arr[i];</span><br><span class="line">    arr[i] = tmp;</span><br><span class="line">    Quick_Sort(arr, begin, i-<span class="number">1</span>);</span><br><span class="line">    Quick_Sort(arr, i+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><h3 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217.存在重复元素"></a>217.存在重复元素</h3><h4 id="题干-4"><a href="#题干-4" class="headerlink" title="题干"></a>题干</h4><p>给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3,1]<br>输出：true<br>示例 2：</p>
<p>输入：nums &#x3D; [1,2,3,4]<br>输出：false<br>示例 3：</p>
<p>输入：nums &#x3D; [1,1,1,3,3,4,3,2,4,2]<br>输出：true</p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p>
<h4 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h4><h5 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1.哈希表"></a>1.哈希表</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       Map&lt;Integer, Integer&gt; hashtbl = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">       <span class="type">int</span> n=nums.length;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(hashtbl.containsKey(nums[i]))</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           hashtbl.put(nums[i],i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O*(*N)，其中 <em>N</em> 为数组的长度。</li>
<li>空间复杂度：O*(<em>N</em>)，其中 N* 为数组的长度。</li>
</ul>
<h5 id="2-排序"><a href="#2-排序" class="headerlink" title="2.排序"></a>2.排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i-<span class="number">1</span>]==nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(NlogN)，其中 N 为数组的长度。需要对数组进行排序。</p>
<p>空间复杂度：O(logN)，其中 N 为数组的长度。注意我们在这里应当考虑递归调用栈的深度。</p>
<h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53.最大子数组和"></a>53.最大子数组和</h3><h4 id="题干-5"><a href="#题干-5" class="headerlink" title="题干"></a>题干</h4><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>子数组 是数组中的一个连续部分。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br>示例 2：</p>
<p>输入：nums &#x3D; [1]<br>输出：1<br>示例 3：</p>
<p>输入：nums &#x3D; [5,4,-1,7,8]<br>输出：23</p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p>
<p>进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。</p>
<h4 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h4><h5 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(pre&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pre+=x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pre&lt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pre=x;</span><br><span class="line">            &#125;</span><br><span class="line">            max=Math.max(pre,max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>思路：遍历一次数组，记录当前和，之前和，最大和，若之前和不大于0，则舍弃，若大于0，则继续与下一个元素相加，每遍历一个元素就将当前和和最大和进行比较，实时更新最大值。dd</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">拓展：</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x :nums)</span><br><span class="line">实际为foreach循环，循环次数与数组长度相同，每次循环的x与数组对应下标的元素相等。</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，其中 n 为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案。<br>空间复杂度：O(1)，我们只需要常数空间存放若干变量。</p>
<h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i-<span class="number">1</span>]&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i]+=nums[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：对每一个元素进行遍历，若前一个元素大于0，则将该元素与前一元素相加，元素实时根据是否相加进行更新，遍历完之后取新数组的最大值即为题干的解。</p>
<p>注意：最后的sort调用增加了此法的时间复杂度。</p>
<h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><h3 id="1-两数之和-1"><a href="#1-两数之和-1" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><p>见Leetcode题库第一题</p>
<h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88.合并两个有序数组"></a>88.合并两个有序数组</h3><h4 id="题干-6"><a href="#题干-6" class="headerlink" title="题干"></a>题干</h4><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<p>示例 1：</p>
<p>输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3<br>输出：[1,2,2,3,5,6]<br>解释：需要合并 [1,2,3] 和 [2,5,6] 。<br>合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。<br>示例 2：</p>
<p>输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0<br>输出：[1]<br>解释：需要合并 [1] 和 [] 。<br>合并结果是 [1] 。<br>示例 3：</p>
<p>输入：nums1 &#x3D; [0], m &#x3D; 0, nums2 &#x3D; [1], n &#x3D; 1<br>输出：[1]<br>解释：需要合并的数组是 [] 和 [1] 。<br>合并结果是 [1] 。<br>注意，因为 m &#x3D; 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</p>
<p>提示：</p>
<p>nums1.length &#x3D;&#x3D; m + n<br>nums2.length &#x3D;&#x3D; n<br>0 &lt;&#x3D; m, n &lt;&#x3D; 200<br>1 &lt;&#x3D; m + n &lt;&#x3D; 200<br>-109 &lt;&#x3D; nums1[i], nums2[j] &lt;&#x3D; 109</p>
<h4 id="解法-6"><a href="#解法-6" class="headerlink" title="解法"></a>解法</h4><h5 id="先合并再排序"><a href="#先合并再排序" class="headerlink" title="先合并再排序"></a>先合并再排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i!=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nums1[m+i]=nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O((m+n)log(m+n))。<br>排序序列长度为 m+nm+n，套用快速排序的时间复杂度即可，平均情况为O((m+n)log(m+n))。</p>
<p>空间复杂度：O(log(m+n))。<br>排序序列长度为 m+nm+n，套用快速排序的空间复杂度即可，平均情况为 O(log(m+n))。</p>
<h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><h4 id="350-两个数组的交集Ⅱ"><a href="#350-两个数组的交集Ⅱ" class="headerlink" title="350.两个数组的交集Ⅱ"></a>350.两个数组的交集Ⅱ</h4><h5 id="题干-7"><a href="#题干-7" class="headerlink" title="题干"></a>题干</h5><p>给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p>
<p>示例 1：</p>
<p>输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]<br>输出：[2,2]<br>示例 2:</p>
<p>输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]<br>输出：[4,9]</p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums1.length, nums2.length &lt;&#x3D; 1000<br>0 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 1000</p>
<p>进阶：</p>
<p>如果给定的数组已经排好序呢？你将如何优化你的算法？<br>如果 nums1 的大小比 nums2 小，哪种方法更优？<br>如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</p>
<h5 id="解法-7"><a href="#解法-7" class="headerlink" title="解法"></a>解法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: nums1)&#123;</span><br><span class="line">            <span class="type">int</span> count=map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>;</span><br><span class="line">            map.put(num,count);</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[Math.max(nums1.length,nums2.length)];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums2)&#123;</span><br><span class="line">            <span class="type">int</span> count=map.getOrDefault(num,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(count&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[index++]=num;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span>(count&gt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    map.put(num,count);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    map.remove(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(arr,<span class="number">0</span>,index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（m+n）</p>
<p>空间复杂度：O（min（m+n））</p>
<h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><p>map.getOrDefault的用法：</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-getordefault.html">Java HashMap getOrDefault() 方法 | 菜鸟教程 (runoob.com)</a></p>
<h4 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h4><h5 id="题干-8"><a href="#题干-8" class="headerlink" title="题干"></a>题干</h5><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<p>示例 1：</p>
<p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br>示例 2：</p>
<p>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<p>提示：</p>
<p>1 &lt;&#x3D; prices.length &lt;&#x3D; 105<br>0 &lt;&#x3D; prices[i] &lt;&#x3D; 104</p>
<h5 id="解法-8"><a href="#解法-8" class="headerlink" title="解法"></a>解法</h5><h6 id="1-暴力遍历"><a href="#1-暴力遍历" class="headerlink" title="1.暴力遍历"></a>1.暴力遍历</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> prices[i];</span><br><span class="line">            <span class="keyword">if</span>(cur &lt; pre)&#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cur &gt; pre) &#123;</span><br><span class="line">                res = res&gt;(cur-pre) ? res:(cur-pre);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（n²）</p>
<p>空间复杂度：O（1）</p>
<h6 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2.动态规划"></a>2.动态规划</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> prices[i];</span><br><span class="line">            <span class="keyword">if</span>(cur &lt; pre)&#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cur &gt; pre) &#123;</span><br><span class="line">                res = res&gt;(cur-pre) ? res:(cur-pre);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：遍历一次数组，没遍历一个数，将之与最小值作比较，小则更新，同时记录max的数值，即边找寻最小值，边计算最大的差值，最终的max即为返回的解。</p>
<p>时间复杂度：O（n）</p>
<p>时间复杂度：O（1）</p>
<h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><h3 id="566-重塑矩阵"><a href="#566-重塑矩阵" class="headerlink" title="566.重塑矩阵"></a>566.重塑矩阵</h3><h4 id="题干-9"><a href="#题干-9" class="headerlink" title="题干"></a>题干</h4><p>在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。</p>
<p>给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。</p>
<p>重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。</p>
<p>如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p>
<p>示例 1：</p>
<p>输入：mat &#x3D; [[1,2],[3,4]], r &#x3D; 1, c &#x3D; 4<br>输出：[[1,2,3,4]]<br>示例 2：</p>
<p>输入：mat &#x3D; [[1,2],[3,4]], r &#x3D; 2, c &#x3D; 4<br>输出：[[1,2],[3,4]]</p>
<p>提示：</p>
<p>m &#x3D;&#x3D; mat.length<br>n &#x3D;&#x3D; mat[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 100<br>-1000 &lt;&#x3D; mat[i][j] &lt;&#x3D; 1000<br>1 &lt;&#x3D; r, c &lt;&#x3D; 300</p>
<h4 id="解法-9"><a href="#解法-9" class="headerlink" title="解法"></a>解法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] matrixReshape(<span class="type">int</span>[][] mat, <span class="type">int</span> r, <span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="type">int</span>[][] ans=<span class="keyword">new</span> <span class="title class_">int</span>[r][c];</span><br><span class="line">        <span class="type">int</span> m=mat.length;</span><br><span class="line">        <span class="type">int</span> n=mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(m * n != r * c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mat;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;r*c;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i/c][i%c]=mat[i/n][i%n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（rc）</p>
<p>空间复杂度：O（1）</p>
<h3 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118.杨辉三角"></a>118.杨辉三角</h3><h4 id="题干-10"><a href="#题干-10" class="headerlink" title="题干"></a>题干</h4><p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<p>示例 1:</p>
<p>输入: numRows &#x3D; 5<br>输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]<br>示例 2:</p>
<p>输入: numRows &#x3D; 1<br>输出: [[1]]</p>
<p>提示:</p>
<p>1 &lt;&#x3D; numRows &lt;&#x3D; 30</p>
<h4 id="解法-10"><a href="#解法-10" class="headerlink" title="解法"></a>解法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> numRows)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;Integer&gt;row =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>||j==i)</span><br><span class="line">                &#123;</span><br><span class="line">                    row.add(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    row.add(list.get(i-<span class="number">1</span>).get(j-<span class="number">1</span>)+list.get(i-<span class="number">1</span>).get(j));</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            list.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（numRows²）</p>
<p>空间复杂度：O（1）</p>
<h2 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h2><h3 id="36-有效的数组"><a href="#36-有效的数组" class="headerlink" title="36.有效的数组"></a>36.有效的数组</h3><h4 id="题干-11"><a href="#题干-11" class="headerlink" title="题干"></a>题干</h4><p>请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</p>
<p>注意：</p>
<p>一个有效的数独（部分已被填充）不一定是可解的。<br>只需要根据以上规则，验证已经填入的数字是否有效即可。<br>空白格用 ‘.’ 表示。</p>
<p>示例 1：</p>
<p>输入：board &#x3D;<br>[[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”]<br>,[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”]<br>,[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”]<br>,[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”]<br>,[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”]<br>,[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”]<br>,[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”]<br>,[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”]<br>,[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]<br>输出：true<br>示例 2：</p>
<p>输入：board &#x3D;<br>[[“8”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”]<br>,[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”]<br>,[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”]<br>,[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”]<br>,[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”]<br>,[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”]<br>,[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”]<br>,[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”]<br>,[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]<br>输出：false<br>解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</p>
<p>提示：</p>
<p>board.length &#x3D;&#x3D; 9<br>board[i].length &#x3D;&#x3D; 9<br>board[i][j] 是一位数字（1-9）或者 ‘.’</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> row[<span class="number">9</span>][<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> col[<span class="number">9</span>][<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> box[<span class="number">9</span>][<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> num=board[i][j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(row[i][num]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(col[j][num]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">int</span> temp=j/<span class="number">3</span>+i/<span class="number">3</span>*<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span>(box[temp][num]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                row[i][num]=<span class="number">1</span>;</span><br><span class="line">                col[j][num]=<span class="number">1</span>;</span><br><span class="line">                box[temp][num]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（1）</p>
<p>空间复杂度：O（2）</p>
<p>重点：<strong>temp&#x3D;j&#x2F;3+i&#x2F;3</strong></p>
<h1 id="Leetcode75"><a href="#Leetcode75" class="headerlink" title="Leetcode75"></a>Leetcode75</h1><h2 id="Leve1"><a href="#Leve1" class="headerlink" title="Leve1"></a>Leve1</h2><h3 id="第一天-1"><a href="#第一天-1" class="headerlink" title="第一天"></a>第一天</h3><h4 id="1480-一维数组的动态和"><a href="#1480-一维数组的动态和" class="headerlink" title="1480.一维数组的动态和"></a>1480.一维数组的动态和</h4><p>给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] &#x3D; sum(nums[0]…nums[i]) 。</p>
<p>请返回 nums 的动态和。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3,4]<br>输出：[1,3,6,10]<br>解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。<br>示例 2：</p>
<p>输入：nums &#x3D; [1,1,1,1,1]<br>输出：[1,2,3,4,5]<br>解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。<br>示例 3：</p>
<p>输入：nums &#x3D; [3,1,2,10,1]<br>输出：[3,4,6,16,17]</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runningSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">        nums[i]=nums[i<span class="number">-1</span>]+nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="724-寻找数组的中心下标"><a href="#724-寻找数组的中心下标" class="headerlink" title="724.寻找数组的中心下标"></a>724.寻找数组的中心下标</h4><p>给你一个整数数组 nums ，请计算数组的 中心下标 。</p>
<p>数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p>
<p>如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p>
<p>如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1, 7, 3, 6, 5, 6]<br>输出：3<br>解释：<br>中心下标是 3 。<br>左侧数之和 sum &#x3D; nums[0] + nums[1] + nums[2] &#x3D; 1 + 7 + 3 &#x3D; 11 ，<br>右侧数之和 sum &#x3D; nums[4] + nums[5] &#x3D; 5 + 6 &#x3D; 11 ，二者相等。<br>示例 2：</p>
<p>输入：nums &#x3D; [1, 2, 3]<br>输出：-1<br>解释：<br>数组中不存在满足此条件的中心下标。<br>示例 3：</p>
<p>输入：nums &#x3D; [2, 1, -1]<br>输出：0<br>解释：<br>中心下标是 0 。<br>左侧数之和 sum &#x3D; 0 ，（下标 0 左侧不存在元素），<br>右侧数之和 sum &#x3D; nums[1] + nums[2] &#x3D; 1 + -1 &#x3D; 0 。</p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</p>
<h5 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pivotIndex</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    sum1:=<span class="number">0</span></span><br><span class="line">    sum2:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">        sum1,sum2=sums(nums,i)</span><br><span class="line">        <span class="keyword">if</span>(sum1==sum2)&#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sums</span><span class="params">(nums []<span class="type">int</span>,i <span class="type">int</span>)</span></span> (<span class="type">int</span>,<span class="type">int</span>)&#123;</span><br><span class="line">    left_sum:=<span class="number">0</span></span><br><span class="line">    right_sum:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;i;j++&#123;</span><br><span class="line">        left_sum+=nums[j]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> l:=i+<span class="number">1</span>;l&lt;<span class="built_in">len</span>(nums);l++&#123;</span><br><span class="line">        right_sum+=nums[l]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left_sum,right_sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题：时间复杂度较高</strong></p>
<h5 id="解法2"><a href="#解法2" class="headerlink" title="解法2."></a>解法2.</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pivotIndex</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    total:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,v:=<span class="keyword">range</span> nums&#123;</span><br><span class="line">        total+=v</span><br><span class="line">    &#125;</span><br><span class="line">    left_sum:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i,v:=<span class="keyword">range</span> nums&#123;</span><br><span class="line">        <span class="keyword">if</span> left_sum*<span class="number">2</span>+v == total&#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">        left_sum+=v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二天-1"><a href="#第二天-1" class="headerlink" title="第二天"></a>第二天</h3><h4 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205.同构字符串"></a>205.同构字符串</h4><p>给定两个字符串 s 和 t ，判断它们是否是同构的。</p>
<p>如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。</p>
<p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p>
<p>示例 1:</p>
<p>输入：s &#x3D; “egg”, t &#x3D; “add”<br>输出：true<br>示例 2：</p>
<p>输入：s &#x3D; “foo”, t &#x3D; “bar”<br>输出：false<br>示例 3：</p>
<p>输入：s &#x3D; “paper”, t &#x3D; “title”<br>输出：true</p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104<br>t.length &#x3D;&#x3D; s.length<br>s 和 t 由任意有效的 ASCII 字符组成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isIsomorphic</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"></span><br><span class="line">	m1 := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">byte</span>&#123;&#125;</span><br><span class="line">	m2 := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">byte</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">		x, y := s[i], t[i]</span><br><span class="line">		<span class="keyword">if</span> m1[x] &gt; <span class="number">0</span> &amp;&amp; m1[x] != y || m2[y] &gt; <span class="number">0</span> &amp;&amp; m2[y] != x &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		m1[x] = y</span><br><span class="line">		m2[y] = x</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392.判断子序列"></a>392.判断子序列</h4><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p>进阶：</p>
<p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<p>致谢：</p>
<p>特别感谢 @pbrother 添加此问题并且创建所有测试用例。</p>
<p>示例 1：</p>
<p>输入：s &#x3D; “abc”, t &#x3D; “ahbgdc”<br>输出：true<br>示例 2：</p>
<p>输入：s &#x3D; “axc”, t &#x3D; “ahbgdc”<br>输出：false</p>
<p>提示：</p>
<p>0 &lt;&#x3D; s.length &lt;&#x3D; 100<br>0 &lt;&#x3D; t.length &lt;&#x3D; 10^4<br>两个字符串都只由小写字符组成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubsequence</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    i:=<span class="number">0</span></span><br><span class="line">    m,n:=<span class="built_in">len</span>(s),<span class="built_in">len</span>(t)</span><br><span class="line">    j:=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j&lt;n &amp;&amp;i&lt;m&#123;</span><br><span class="line">        <span class="keyword">if</span> s[i]==t[j]&#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i==m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第三天-1"><a href="#第三天-1" class="headerlink" title="第三天"></a>第三天</h3><h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h4><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>示例 1：</p>
<p>输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]<br>输出：[1,1,2,3,4,4]<br>示例 2：</p>
<p>输入：l1 &#x3D; [], l2 &#x3D; []<br>输出：[]<br>示例 3：</p>
<p>输入：l1 &#x3D; [], l2 &#x3D; [0]<br>输出：[0]</p>
<p>提示：</p>
<p>两个链表的节点数目范围是 [0, 50]<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>l1 和 l2 均按 非递减顺序 排列<br>通过次数1,242,167提交次数1,866,989</p>
<h5 id="法1-递归"><a href="#法1-递归" class="headerlink" title="法1.递归"></a>法1.递归</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    l3 :=&amp;ListNode&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l1.Val &gt;= l2.Val&#123;</span><br><span class="line">        l3=l2</span><br><span class="line">        l3.Next =mergeTwoLists(l1,l2.Next)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l3=l1</span><br><span class="line">        l3.Next = mergeTwoLists(l1.Next,l2)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="法2-迭代"><a href="#法2-迭代" class="headerlink" title="法2.迭代"></a>法2.迭代</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    dummyHead := &amp;ListNode&#123;&#125;</span><br><span class="line">    prev := dummyHead</span><br><span class="line">    <span class="keyword">for</span> l1 !=<span class="literal">nil</span> &amp;&amp;l2!=<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> l1.Val &gt;= l2.Val&#123;</span><br><span class="line">            prev.Next=l2</span><br><span class="line">            l2=l2.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.Next=l1</span><br><span class="line">            l1=l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        prev=prev.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span>&#123;</span><br><span class="line">        prev.Next=l1</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        prev.Next=l2</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummyHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h4><p>你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]<br>示例 2：</p>
<p>输入：head &#x3D; [1,2]<br>输出：[2,1]<br>示例 3：</p>
<p>输入：head &#x3D; []<br>输出：[]</p>
<p>提示：</p>
<p>链表中节点的数目范围是 [0, 5000]<br>-5000 &lt;&#x3D; Node.val &lt;&#x3D; 5000</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">var</span> prev *ListNode</span><br><span class="line">    <span class="keyword">for</span> head != <span class="literal">nil</span>&#123;</span><br><span class="line">        temp:=head.Next</span><br><span class="line">        head.Next=prev</span><br><span class="line">        prev=head</span><br><span class="line">        head=temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第四天-1"><a href="#第四天-1" class="headerlink" title="第四天"></a>第四天</h3><h4 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876.链表的中间结点"></a>876.链表的中间结点</h4><p>给定一个头结点为 head 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<p>示例 1：</p>
<p>输入：[1,2,3,4,5]<br>输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, 以及 ans.next.next.next &#x3D; NULL.<br>示例 2：</p>
<p>输入：[1,2,3,4,5,6]<br>输出：此列表中的结点 4 (序列化形式：[4,5,6])<br>由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</p>
<p>提示：</p>
<p>给定链表的结点数介于 1 和 100 之间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleNode</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    slow:=head</span><br><span class="line">    fast:=head</span><br><span class="line">    <span class="keyword">for</span> fast!=<span class="literal">nil</span> &amp;&amp; fast.Next!=<span class="literal">nil</span>&#123;</span><br><span class="line">        slow=slow.Next</span><br><span class="line">        fast=fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="142-环形链表Ⅱ"><a href="#142-环形链表Ⅱ" class="headerlink" title="142.环形链表Ⅱ"></a>142.环形链表Ⅱ</h4><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
<p>示例 1：</p>
<p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p>示例 2：</p>
<p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。</p>
<p>示例 3：</p>
<p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：返回 null<br>解释：链表中没有环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    read := <span class="keyword">map</span>[*ListNode]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := read[head]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        &#125;</span><br><span class="line">        read[head] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第五天-1"><a href="#第五天-1" class="headerlink" title="第五天"></a>第五天</h3><h4 id="121-买卖股票的最佳时机-1"><a href="#121-买卖股票的最佳时机-1" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h4><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<p>示例 1：</p>
<p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br>示例 2：</p>
<p>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<p>提示：</p>
<p>1 &lt;&#x3D; prices.length &lt;&#x3D; 105<br>0 &lt;&#x3D; prices[i] &lt;&#x3D; 104</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> min = prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> profit <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> _, price := <span class="keyword">range</span> prices[<span class="number">1</span>:] &#123;</span><br><span class="line">        <span class="keyword">if</span> profit &lt; price - min &#123;</span><br><span class="line">            profit = price - min</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> min &gt; price &#123;</span><br><span class="line">            min = price</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409.最长回文串"></a>409.最长回文串</h4><p>给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。</p>
<p>在构造过程中，请注意 区分大小写 。比如 “Aa” 不能当做一个回文字符串。</p>
<p>示例 1:</p>
<p>输入:s &#x3D; “abccccdd”<br>输出:7<br>解释:<br>我们可以构造的最长的回文串是”dccaccd”, 它的长度是 7。<br>示例 2:</p>
<p>输入:s &#x3D; “a”<br>输入:1<br>示例 3：</p>
<p>输入:s &#x3D; “aaaaaccc”<br>输入:7<br>提示:</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 2000<br>s 只由小写 和&#x2F;或 大写英文字母组成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	hash := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		hash[s[i]]++</span><br><span class="line">	&#125;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> hash &#123;</span><br><span class="line">		<span class="keyword">if</span> v&amp;<span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">			res += v - <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			res += v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> res&lt;<span class="built_in">len</span>(s) &#123;</span><br><span class="line">		res++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第八天"><a href="#第八天" class="headerlink" title="第八天"></a>第八天</h3><h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h4><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p>
<p>示例 1：</p>
<p>输入：root &#x3D; [2,1,3]<br>输出：true<br>示例 2：</p>
<p>输入：root &#x3D; [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 。</p>
<p>提示：</p>
<p>树中节点数目范围在[1, 104] 内<br>-231 &lt;&#x3D; Node.val &lt;&#x3D; 231 - 1</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    stack:=[]*TreeNode&#123;&#125;</span><br><span class="line">    num:=math.MinInt64</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack)!=<span class="number">0</span>||root!=<span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> root!=<span class="literal">nil</span>&#123;</span><br><span class="line">            stack=<span class="built_in">append</span>(stack,root)</span><br><span class="line">            root = root.Left</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[<span class="number">0</span>:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> root.Val &lt;= num &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        num =root.Val</span><br><span class="line">        root=root.Right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235.二叉搜索树的最近公共祖先"></a>235.二叉搜索树的最近公共祖先</h4><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树:  root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p>
<p>示例 1:</p>
<p>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。<br>示例 2:</p>
<p>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>说明:</p>
<p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉搜索树中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val   int</span></span><br><span class="line"><span class="comment"> *     Left  *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">for</span> root!=<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> p.Val&lt;root.Val &amp;&amp; q.Val&lt;root.Val&#123;</span><br><span class="line">            root = root.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> p.Val &gt; root.Val &amp;&amp; q.Val &gt; root.Val&#123;</span><br><span class="line">            root =root.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第九天"><a href="#第九天" class="headerlink" title="第九天"></a>第九天</h3><h4 id="733-图像渲染"><a href="#733-图像渲染" class="headerlink" title="733.图像渲染"></a>733.图像渲染</h4><p>有一幅以 m x n 的二维整数数组表示的图画 image ，其中 image[i][j] 表示该图画的像素值大小。</p>
<p>你也被给予三个整数 sr ,  sc 和 newColor 。你应该从像素 image[sr][sc] 开始对图像进行 上色填充 。</p>
<p>为了完成 上色工作 ，从初始像素开始，记录初始坐标的 上下左右四个方向上 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 四个方向上 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 newColor 。</p>
<p>最后返回 经过上色渲染后的图像 。</p>
<p>示例 1:</p>
<p>输入: image &#x3D; [[1,1,1],[1,1,0],[1,0,1]]，sr &#x3D; 1, sc &#x3D; 1, newColor &#x3D; 2<br>输出: [[2,2,2],[2,2,0],[2,0,1]]<br>解析: 在图像的正中间，(坐标(sr,sc)&#x3D;(1,1)),在路径上所有符合条件的像素点的颜色都被更改成2。<br>注意，右下角的像素没有更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。<br>示例 2:</p>
<p>输入: image &#x3D; [[0,0,0],[0,0,0]], sr &#x3D; 0, sc &#x3D; 0, newColor &#x3D; 2<br>输出: [[2,2,2],[2,2,2]]</p>
<p>提示:</p>
<p>m &#x3D;&#x3D; image.length<br>n &#x3D;&#x3D; image[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 50<br>0 &lt;&#x3D; image[i][j], newColor &lt; 216<br>0 &lt;&#x3D; sr &lt; m<br>0 &lt;&#x3D; sc &lt; n</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    dx = []<span class="type">int</span>&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">    dy = []<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">floodFill</span><span class="params">(image [][]<span class="type">int</span>, sr <span class="type">int</span>, sc <span class="type">int</span>, color <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    currcolor:=image[sr][sc]</span><br><span class="line">    <span class="keyword">if</span> currcolor != color &#123;</span><br><span class="line">        dfs(image,sr,sc,currcolor,color)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(image [][]<span class="type">int</span>,x,y,currcolor,color <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> image[x][y]==currcolor&#123;</span><br><span class="line">        image[x][y]=color</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++&#123;</span><br><span class="line">            tx,ty:=x+dx[i],y+dy[i]</span><br><span class="line">            <span class="keyword">if</span> tx&gt;=<span class="number">0</span>&amp;&amp;tx&lt;<span class="built_in">len</span>(image)&amp;&amp;ty&gt;=<span class="number">0</span>&amp;&amp;ty&lt;<span class="built_in">len</span>(image[<span class="number">0</span>]) &#123;</span><br><span class="line">                dfs(image,tx,ty,currcolor,color)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第十天"><a href="#第十天" class="headerlink" title="第十天"></a>第十天</h3><h4 id="509-斐波那契数列"><a href="#509-斐波那契数列" class="headerlink" title="509.斐波那契数列"></a>509.斐波那契数列</h4><p>斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<p>F(0) &#x3D; 0，F(1) &#x3D; 1<br>F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1<br>给定 n ，请计算 F(n) 。</p>
<p>示例 1：</p>
<p>输入：n &#x3D; 2<br>输出：1<br>解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1<br>示例 2：</p>
<p>输入：n &#x3D; 3<br>输出：2<br>解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2<br>示例 3：</p>
<p>输入：n &#x3D; 4<br>输出：3<br>解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3</p>
<p>提示：</p>
<p>0 &lt;&#x3D; n &lt;&#x3D; 30</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125; </span><br><span class="line">    f1,f2,f3:=<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span>;i&lt;n;i++ &#123;</span><br><span class="line">        f1=f2</span><br><span class="line">        f2=f3</span><br><span class="line">        f3=f1+f2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h4><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>示例 1：</p>
<p>输入：n &#x3D; 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶<br>示例 2：</li>
</ol>
<p>输入：n &#x3D; 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 45</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125; </span><br><span class="line">    f1,f2,f3:=<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span>;i&lt;n;i++ &#123;</span><br><span class="line">        f1=f2</span><br><span class="line">        f2=f3</span><br><span class="line">        f3=f1+f2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第十一天"><a href="#第十一天" class="headerlink" title="第十一天"></a>第十一天</h3><p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>
<p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p>
<p>请你计算并返回达到楼梯顶部的最低花费。</p>
<p>示例 1：</p>
<p>输入：cost &#x3D; [10,15,20]<br>输出：15<br>解释：你将从下标为 1 的台阶开始。</p>
<ul>
<li>支付 15 ，向上爬两个台阶，到达楼梯顶部。<br>总花费为 15 。<br>示例 2：</li>
</ul>
<p>输入：cost &#x3D; [1,100,1,1,1,100,1,1,100,1]<br>输出：6<br>解释：你将从下标为 0 的台阶开始。</p>
<ul>
<li>支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。</li>
<li>支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。</li>
<li>支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。</li>
<li>支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。</li>
<li>支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。</li>
<li>支付 1 ，向上爬一个台阶，到达楼梯顶部。<br>总花费为 6 。</li>
</ul>
<p>提示：</p>
<p>2 &lt;&#x3D; cost.length &lt;&#x3D; 1000<br>0 &lt;&#x3D; cost[i] &lt;&#x3D; 999</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	动态规划</span></span><br><span class="line"><span class="comment">	方程为：</span></span><br><span class="line"><span class="comment">	f[i]=min(f[i-1]+cost[i-1],f[i-2]+cost[i-2])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    cost_len:=<span class="built_in">len</span>(cost)</span><br><span class="line">    f:=<span class="built_in">make</span>([]<span class="type">int</span> , cost_len+<span class="number">1</span>)</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span>;i&lt;=cost_len;i++ &#123;</span><br><span class="line">        f[i]=min(f[i<span class="number">-1</span>]+cost[i<span class="number">-1</span>],f[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[cost_len]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a <span class="type">int</span>,b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a&gt;b &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h4><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p>示例 1：</p>
<p>输入：m &#x3D; 3, n &#x3D; 7<br>输出：28<br>示例 2：</p>
<p>输入：m &#x3D; 3, n &#x3D; 2<br>输出：3<br>解释：<br>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li>向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向下<br>示例 3：</li>
</ol>
<p>输入：m &#x3D; 7, n &#x3D; 3<br>输出：28<br>示例 4：</p>
<p>输入：m &#x3D; 3, n &#x3D; 3<br>输出：6</p>
<p>提示：</p>
<p>1 &lt;&#x3D; m, n &lt;&#x3D; 100<br>题目数据保证答案小于等于 2 * 109</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="题干图示例"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：</span></span><br><span class="line"><span class="comment">0 ms, 在所有 Go 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：</span></span><br><span class="line"><span class="comment">1.9 MB, 在所有 Go 提交中击败了56.14%的用户</span></span><br><span class="line"><span class="comment">通过测试用例：</span></span><br><span class="line"><span class="comment">63 / 63</span></span><br><span class="line"><span class="comment">2022/12/21 20：11</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">动态规划</span></span><br><span class="line"><span class="comment">方程为：dp[i][j]=dp[i-1][j]+dp[i][j-1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePaths</span><span class="params">(m <span class="type">int</span>, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">     dp := <span class="built_in">make</span>([][]<span class="type">int</span>, m)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++ &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i]=<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;m;i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span>;j&lt;n;j++ &#123;</span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/16/test/" data-id="clxjz1poa0003h8v41cdc9rfy" data-title="letcode" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-First-Blog" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/15/First-Blog/" class="article-date">
  <time class="dt-published" datetime="2024-06-15T15:45:04.000Z" itemprop="datePublished">2024-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/15/First-Blog/">First Blog</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Sherry</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/15/First-Blog/" data-id="clxjz1pnt0000h8v47gbh80go" data-title="First Blog" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/06/18/hello-world/">NMSL</a>
          </li>
        
          <li>
            <a href="/2024/06/16/letcode/">letcode</a>
          </li>
        
          <li>
            <a href="/2024/06/16/test/">letcode</a>
          </li>
        
          <li>
            <a href="/2024/06/15/First-Blog/">First Blog</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>